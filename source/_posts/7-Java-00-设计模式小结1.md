---
title: 设计模式小结(1)
comments: true
date: 2020-04-08 10:57
categories: [设计模式]
tags: [设计模式]
---

上篇： [浅读设计模式之禅](http://jasonzeng.top/2018/10/08/8-Book-The-Zen-of-Design-Patterns/)

## 设计模式的对比




## 一些疑惑？？？

使用各种设计模式，感觉很多都有关联性

比如：
策略模式中的Context 似乎也符合组合模式？

委派模式也可理解为策略模式？ 委派给不同的对象执行，换个说法也就是使用不同的策略去执行；
如项目经理委派任务给员工A或者员工B， 那么也可以理解为项目经理使用了“员工A”策略，或者使用了“员工B”策略

委派模式跟代理模式（静态代理）也很相似？ 假如代理模式中的代理在 invoke 前后不做操作，那么跟委托模式描述是一样的？

有的时候，复合和转发的结合被错误的称为"委托(delegation)"。从技术的角度来说，这不是委托，除非包装对象把自身传递给被包装的对象。

> 委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式


## 关于继承

### 什么时候使用继承？

通过子类继承父类并不是代码重用的最好手段，有这样的缺点：
1. 与方法调用不同的是，继承打破封装性。子类依赖于父类，如果父类的具体实现细节改变，子类也会跟着相应改变。除非父类就是专门为扩展而设计的，并且有良好的文档说明
2. 父类方法中的”自用性“问题，导致的子类方法逻辑出错

为了避免这种情况，**可以使用复合和转发机制来代替继承**，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更强大

**只有当子类真正是超类的子类型(subtype)时，才适合用继承。** 对于两个类A和B，只有当两者之间确实存在"is-a"的关系的时候，类B才应该扩展A。如果打算让类B扩展类A，就应该确定一个问题：B确实也是A吗？如果不能确定答案是肯定的，那么B就不应该扩展A。如果答案是否定的，通常情况下B应该包含A的一个私有实例，并且暴露一个较小的、较简单的API：A本质上不是B的一部分，只是它的实现细节而已(使用API的客户端无需知道)。


